Jetraw Core FPGA implementation 
===============================

Jetraw Core is also implemented in VHDL, for deployment to FPGA's. Information
about the FPGA implementation is available on demand, by contacting Dotphoton
directly. This section of the documentation focuses on using the software
implementation to decode compressed buffers produced by the FPGA implementation.

Compressed buffer format
~~~~~~~~~~~~~~~~~~~~~~~~~

It is important to save the compressed buffer generated by the FPGA
implementation "as-is", without adding any padding at the beginning or end of
the file. Introducing padding will cause the decoding process to fail.

Compatibility with software tools and libraries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Currently, FPGA generated compressed buffers are only compatible with the direct
image buffer decoding function, ``jetraw_decode``, provided by the C++ library. It
is not possible to decode any FPGA generated compressed buffers using the GUI,
the CLI or the tiff related functions.

Decoding FPGA compressed buffers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following example code shows how to decode FPGA encoded image buffers. The
output of the ``jetraw_decode`` function is still a raw image buffer, additional
logic is required to store the buffer into a more convenient container.

.. code-block:: cpp
    // Copyright 2025 Dotphoton AG
    #include <iostream>
    #include <fstream>
    #include <filesystem>
    #include <vector>

    #include "jetraw/jetraw.h"
    #include "jetraw/dp_status.h"


    int main(int argc, char** argv){
        std::filesystem::path source_path("<path-to-encoded-buffer>");
        auto image_height = <decoded-height>;
        auto iamge_width = <decoded-width>;

        // Load image
        std::ifstream source_stream(source_path);
        std::vector<char> source_buffer(std::filesystem::file_size(source_path));
        source_stream.read(source_buffer.data(), source_buffer.size());

        // Prepare destination buffer
        std::vector<uint16_t> destination_buffer(image_height * iamge_width);

        // Decode image
        auto status = jetraw_decode(source_buffer.data(), 
                                    source_buffer.size(), destination_buffer.data(), 
                                    image_height * iamge_width);

        // Check status
        if (status != dp_success){
            std::cout << dp_status_description(status) << std::endl;
            return 1;
        }

        return 0;
    }